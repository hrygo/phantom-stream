# Phase 8 策略调研：渲染强绑定 (Rendering Strong Binding)

**日期**: 2025-12-05
**状态**: 规划中
**目标**: 抵御针对独立流对象的"精准清洗"和"暴力填充"攻击。

## 1. 背景与动机

### 1.1 Phase 7 失败复盘
在 Phase 7 中，我们采用了双锚点（附件 + SMask）策略。虽然提高了隐蔽性，但这两个锚点都有一个共同弱点：**它们都是独立的流对象 (Stream Object)**。
*   **附件**：独立的 EmbeddedFile Stream。
*   **SMask**：独立的 Image XObject Stream。

红队的攻击逻辑是：
1.  **定位**：找到这些流对象（通过引用关系或特征）。
2.  **清洗**：直接用 `0x00` 填充流内容，或者用空数据替换。
3.  **结果**：签名消失，但 PDF 骨架（Pages, Content）完好，文件依然可读。

### 1.2 Phase 8 核心理念：清洗即损毁
为了对抗上述攻击，必须将水印信息从"旁路数据"（附件/蒙版）迁移到"核心数据"（页面内容）中。
**目标**：使得水印成为页面渲染逻辑不可分割的一部分。如果红队试图清洗水印，必须破坏页面的视觉呈现（如文字消失、乱码、排版错乱）。

## 2. 技术方案选型

### 2.1 候选方案 A：内容流微扰 (Content Stream Perturbation) [首选]
利用 PDF 的文本显示操作符（主要是 `TJ`）进行隐写。
*   **原理**：`TJ` 操作符允许在字符串之间插入数字，用于调整字间距（Kerning）。
    *   正常：`[(H) 10 (e) 10 (l) 10 (l) 10 (o)] TJ`
    *   隐写：`[(H) 10.001 (e) 9.999 (l) ... ] TJ`
*   **编码**：利用数值的小数位或微小偏移量编码比特。
*   **隐蔽性**：肉眼无法区分 0.001 文本单位的偏移。
*   **抗攻击性**：
    *   **流填充攻击**：如果红队清空 Content Stream，页面变白板。❌ 红队失败。
    *   **结构清洗**：Content Stream 是页面核心，不能删除。
    *   **数值归一化**：红队必须解析 Content Stream，识别 `TJ` 指令，并将所有数值取整或重置。这需要编写复杂的 Content Stream 解析器，且可能破坏原始排版（如果原始文档依赖精确的 Kerning）。

### 2.2 候选方案 B：字形数据编码 (Glyph Data Encoding)
修改嵌入字体文件（FontFile Stream）的内部数据。
*   **原理**：在字体的 Glyf 表或 CFF 数据中嵌入信息。
*   **抗攻击性**：清洗字体流会导致文字无法显示。
*   **缺点**：实现复杂度极高，需要解析 TrueType/OpenType/CFF 格式；且红队可以通过"字体替换"或"轮廓重建"来清洗。

### 2.3 决策
选择 **方案 A (内容流微扰)**。
*   **理由**：
    1.  `pdfcpu` 已具备 Content Stream 的解析和写入能力。
    2.  实现成本适中（相比字体解析）。
    3.  能有效防御 Phase 7 遇到的"流填充"攻击。

## 3. Phase 8 详细设计 (Content Stream Perturbation)

### 3.1 注入逻辑 (Injector)
1.  **遍历页面**：获取每一页的 Content Stream。
2.  **解析指令**：将 Stream 解析为操作符序列。
3.  **定位目标**：寻找 `TJ` (Show text with positioning) 操作符。
    *   结构：`[ (string) num (string) num ... ] TJ`
4.  **嵌入载荷**：
    *   将加密后的 Payload（比特流）嵌入到 `num` (字间距数值) 中。
    *   **策略**：
        *   如果 `num` 存在：修改其低位（LSB）。
        *   如果仅有 `Tj` (Show text) 操作符：将其转换为 `TJ`，并插入微小的 `0` 或 `0.001` 偏移量。
        *   例如：`(Hello) Tj` -> `[(H) 0.01 (e) -0.01 (l) 0 (l) 0 (o)] TJ`
5.  **重组流**：将修改后的操作符序列重新序列化为 Content Stream。
6.  **更新页面**：用新 Stream 替换旧 Stream。

### 3.2 提取逻辑 (Extractor)
1.  **遍历页面**：读取 Content Stream。
2.  **解析指令**：寻找 `TJ` 操作符。
3.  **提取数值**：收集所有 `TJ` 数组中的数值。
4.  **解码比特**：根据编码规则（如 `val % 2` 或小数位特征）还原比特流。
5.  **解密验证**：使用 AES-256-GCM 验证 Payload 完整性。

### 3.3 编码鲁棒性设计
*   **冗余编码**：由于页面内容有限，且可能存在解析误差，采用高冗余度编码（如重复多次）。
*   **同步头**：在比特流中插入 Magic Header 用于定位起始位置。
*   **量化容差**：考虑到浮点数精度问题，编码应具有容错性（例如：>0 为 1，<=0 为 0，或者基于奇偶校验但允许误差）。

## 4. 预期对抗效果
*   **红队操作**：`StreamCleaner` (填充 0)。
    *   **结果**：页面内容消失，文档损坏。
*   **红队操作**：删除附件/SMask。
    *   **结果**：无效，水印在 Content Stream 中。
*   **红队操作**：数值归一化 (Rounding)。
    *   **结果**：这是红队唯一可行的路径。红队需要开发 Content Stream Parser，识别 `TJ` 并重置数值。这显著提高了攻击门槛（从"字节填充"升级到"语义解析与重构"）。

## 5. 开发计划
1.  **原型开发**：实现 `AnchorContent`，支持解析 Content Stream 并识别 `TJ`。
2.  **编码实现**：实现 `TJ` 数值修改与比特嵌入。
3.  **集成测试**：验证注入后的 PDF 是否可读，以及水印是否可提取。
